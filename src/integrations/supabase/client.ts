// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://yqcgqriecxtppuvcguyj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlxY2dxcmllY3h0cHB1dmNndXlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ2OTI4NjksImV4cCI6MjA2MDI2ODg2OX0.PD0W-rLpQBHUGm9--nv4-3PVYQFMAsRujmExBDuP5oA";

// Safari detection - used only for logging purposes here
const isSafari = () => {
  const userAgent = navigator.userAgent;
  return userAgent.includes('Safari') && !userAgent.includes('Chrome') && !userAgent.includes('Android');
};

// Detect mobile devices for logging and handling
const isMobileDevice = () => {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
};

// Log configuration details for debugging
console.log('Supabase client configuration:', { 
  url: SUPABASE_URL,
  keyLength: SUPABASE_PUBLISHABLE_KEY?.length ?? 0,
  isConfigured: !!SUPABASE_URL && !!SUPABASE_PUBLISHABLE_KEY,
  isSafari: isSafari(),
  isMobile: isMobileDevice()
});

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Define profile type that can be used in the app
export type Profile = Database['public']['Tables']['profiles']['Row'];

// Create a resilient storage implementation
const createResilientStorage = () => {
  // Keep an in-memory backup of auth data for reliability
  let memoryStorage: Record<string, string> = {};
  
  const storage = {
    getItem: (key: string): string | null => {
      try {
        // First try localStorage
        const item = localStorage.getItem(key);
        console.log(`[Auth Storage] Retrieved ${key}: ${item ? 'exists' : 'null'}`);
        
        // If found in localStorage, keep memory copy in sync
        if (item) {
          memoryStorage[key] = item;
          return item;
        }
        
        // Fall back to memory copy if available
        const memoryItem = memoryStorage[key];
        if (memoryItem) {
          console.log(`[Auth Storage] Retrieved ${key} from memory backup`);
          
          // Try to restore localStorage from memory
          try {
            localStorage.setItem(key, memoryItem);
          } catch (e) {
            // Silent fail
          }
          
          return memoryItem;
        }
        
        // Try sessionStorage as last resort (for cross-tab recovery)
        try {
          const sessionItem = sessionStorage.getItem(key);
          if (sessionItem) {
            console.log(`[Auth Storage] Recovered ${key} from sessionStorage`);
            memoryStorage[key] = sessionItem;
            return sessionItem;
          }
        } catch (e) {
          // Silent fail
        }
        
        return null;
      } catch (error) {
        console.error('[Auth Storage] Storage access error:', error);
        // Return from memory if available
        return memoryStorage[key] || null;
      }
    },
    
    setItem: (key: string, value: string): void => {
      try {
        console.log(`[Auth Storage] Setting ${key}`);
        
        // Always keep a memory backup
        memoryStorage[key] = value;
        
        // Try localStorage
        localStorage.setItem(key, value);
        
        // On Safari/Mobile, verify and use sessionStorage as backup
        if (isSafari() || isMobileDevice()) {
          const verifyValue = localStorage.getItem(key);
          if (verifyValue !== value) {
            console.warn('[Auth Storage] Storage verification failed - using fallbacks');
            
            // Try sessionStorage as backup
            try {
              sessionStorage.setItem(key, value);
            } catch (e) {
              console.warn('[Auth Storage] SessionStorage backup failed:', e);
            }
          }
        }
      } catch (error) {
        console.error('[Auth Storage] Storage write error:', error);
        
        // Try sessionStorage as fallback
        try {
          sessionStorage.setItem(key, value);
        } catch (e) {
          console.warn('[Auth Storage] SessionStorage fallback failed:', e);
          // We still have the memory copy at least
        }
      }
    },
    
    removeItem: (key: string): void => {
      try {
        console.log(`[Auth Storage] Removing ${key}`);
        
        // Clear from memory first
        delete memoryStorage[key];
        
        // Clear from localStorage
        localStorage.removeItem(key);
        
        // Also clear from sessionStorage
        try {
          sessionStorage.removeItem(key);
        } catch (e) {
          // Silent fail
        }
        
        // Verify removal on problematic browsers
        if ((isSafari() || isMobileDevice()) && localStorage.getItem(key)) {
          console.warn(`[Auth Storage] Failed to remove item ${key}`);
          
          // Force clear by setting to empty string as last resort
          try {
            localStorage.setItem(key, '');
          } catch (e) {
            // Silent fail
          }
        }
      } catch (error) {
        console.error('[Auth Storage] Storage remove error:', error);
      }
    }
  };
  
  return storage;
};

// Create and export the supabase client with explicit auth storage configuration
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storage: createResilientStorage()
    },
    // Add better fetch behavior
    global: {
      fetch: (...args) => {
        // Get the request options
        const [url, options = {}] = args;
        
        // Set a reasonable timeout for mobile
        const timeoutMs = isMobileDevice() ? 15000 : 10000;
        
        return new Promise((resolve, reject) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
            reject(new Error('Request timeout'));
          }, timeoutMs);
          
          // Add the signal to the options
          const fetchOptions = {
            ...options,
            signal: controller.signal
          };
          
          fetch(url, fetchOptions)
            .then(response => {
              clearTimeout(timeoutId);
              resolve(response);
            })
            .catch(error => {
              clearTimeout(timeoutId);
              reject(error);
            });
        });
      }
    }
  }
);

// Setup a health check for the Supabase connection with timeout and retry
(async () => {
  const maxRetries = isSafari() ? 3 : 2;
  let attempt = 0;
  
  const checkConnection = async () => {
    try {
      const { error } = await supabase.auth.getSession();
      if (error) {
        throw error;
      }
      console.log('Supabase connection check successful');
      return true;
    } catch (err) {
      console.error(`Supabase connection check failed (attempt ${attempt + 1}/${maxRetries}):`, err);
      return false;
    }
  };
  
  while (attempt < maxRetries) {
    const success = await checkConnection();
    if (success) break;
    
    attempt++;
    if (attempt < maxRetries) {
      // Wait with exponential backoff
      const delay = Math.pow(2, attempt) * 1000;
      console.log(`Retrying Supabase connection in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  if (attempt === maxRetries) {
    console.error('Supabase client initialization failed after multiple attempts');
  }
})();
